# Установка
npm install vuelidate --save



# Регистрация
## Глобально
import Vue from 'vue'
import Vuelidate from 'vuelidate'

Vue.use(Vuelidate)


## Локально
import { validationMixin } from 'vuelidate'

var Component = Vue.extend({
  mixins: [validationMixin],
  validations: { ... }
})





# Пропись <input>
## Статическая


## <input> по v-for
##a) Отталкиваясь от полей validations
См. файл с кодом - src/components/V-for_at_<input>[ ].vue
//https://vuelidate.js.org/#sub-collections-validation
Здесь в v-for поступает поле people из validations(!), а не из data().

<div v-for="(item, index) in $v.people.$each.$iter">
  <input v-model="item.name.$model"
         :class="{error: !item.val.integer && !item.val.exactNumberLength}"
  />
</div>

<div class="error" v-if="!item.name.required">Name is required.</div>
<button class="button" @click="people.push({name: ''})">Add</button>



data: () => ({
people: [{ name: 'John'}, { name: '' }]
}),
validations: {
  people: {
    required,                     //это валидаторы к состоянию массива people.
    minLength: minLength(3),  //минимальный размер листа people. Минимум 3 члена в массиве.
    $each: {
      name: {
        required,
        minLength: minLength(2)
      }
    }
  }
},
methods: {
  send(ev) {
    this.$v.people.$each[currentIdIndex].$invalid      //обращение к отдельному item at people
    this.$v.people.$invalid                            //обращение ко всем членам people скопом  
  }
}




##a) Отталкиваясь от полей data()
Декларация data() и validations - жестко прописана, 
и количество форм-полей- НЕ динамическое.

      <div v-for="(field, key, ind) in forms" :key="ind" class="forms__field">
        <h2 v-if="(field.name !== 'password confirm') || registration"
            :class="{
              'error': $v.forms[key].value.$error || forms[key].isDirty,
              'valid': !$v.forms[key].value.$invalid && forms[key].value.length > 0
            }"
        >
          {{field.name}}
        </h2>

        <input type="text"   <!-- или type="password"(!)-->
               v-model="field.value"
               :placeholder="field.placeholder"
               v-mask="field.mask ? field.mask : ''"
               @blur="$v.forms[key].value.$touch()"
               v-if="(field.name !== 'password confirm') || registrationInterface"
        >
<!--     v-if для того, что бы одно из полей (подтверждение пароля, 'password confirm'), появлялось только при включении registrationInterface-->
      </div>




# Декларация валидаторов
## Стандартная
<input type="text" v-model.trim="$v.userName.$model"/>
<input type="password" v-model.lazy="$v.password.$model"/>

import { required, minLength } from 'vuelidate/lib/validators'

data: () => ({
  form: {
    userName: '',
    password: ''
  }
}),
validations: {
  form: {
    userName: {
      required
    },
    password: {
      required,
      minLength: minLength(8)
    }
  }
}





## Динамическая ДЕКЛАРАЦИЯ всего validations:{}.
validations() {
  if (!this.hasDescription) {  //Количество  охваченных валидацией полей переключается by this.hasDescription.
    return {
      name: {
        required
      }
    }
  } else {
    return {
      name: {
        required
      },
      description: {
        required
      }
    }
  }
}



## Динамическая декларация ИМЕНИ отдельного валидатора и ПАРАМЕТРОВ конкретного валидатора.
  validations() {
    return {
      name: {
        [this.valName]: minLength(this.minLength)
      }
    }
  }




# Включение required от третьих условий (галочка в чекбоксе, например).
validations: {
  people: {
    required: requiredIf(function() {
      return this.admission                    //boolean
    })
  }
}





# = РЕЗУЛЬТАТ валидации как выглядит.
## Особенность $invalid
Если name = null, то $v.name.$invalid даст true(!).


## Особенность $dirty
- предварительно должен быть запущен $touch().


## Особенность $error
- это сочетание "$invalid" + "$dirty".


## Селективность уровня при получении ответа валидации.
this.$v.$invalid         //для ВСЕХ переменных.
this.$v.forms.$invalid      //только для forms-переменной.
this.$v.forms.age.$invalid     //только для конкретного age-поля (по данному <input>) у forms-переменной. По всем его валидаторам в сумме.
this.$v.form.age.required        //по данному валидатору у конкретного поля (по данному <input>).


##1. Результат по ВСЕМ проверяемым <input> вкупе.
this.$v = {
  "$invalid": false,
  "$anyDirty": true,
  "$anyError": false,
  "$each": {    //набор всех валидируемых моделей
    $iter: {}  //all validation models в чистом виде.
    ...
  },
  //Далее идет детализация по конкретным <input> и конкретным валидаторам...
}

##2. Результат по данному <input>
this.$v.form.age.$error

this.$v.form.age = {
  "between": true,    //результат валидации конкретного валидатора у данного <input>.
  "$model": "22",     //значение, поступившее в валидатор из данного <input>.

  "$invalid": false,   //null дает true(!!!)

  "$dirty": true,     // = ВСЕ дети - затронуты.   //$touch() нужен исключительно для него(!).
  "$anyDirty": true,  // = Хоть КТО-ТО из детей затронут.

  "$error": false,    // сочетание "$invalid" + "$dirty"
  "$anyError": false,

  "$pending": false,  //true - между запуском валидации и получением результата. Для асинхронных валидаций. У синхронных валидаторов всегда false.
  
  "$params": {        //установленные ПАРАМЕТРЫ для конкретного валидатора. For reporting errors to users.
    "between": {      //{{ $v.form.age.$params.between.min }}
      "type": "between",
      "min": 20,
      "max": 30
    }
  }
}

##3. по конкретному валидатору у данного <input>
this.$v.form.password.required




# Декларация $touch().
## Польза от $touch().
$touch() нужен только для запуска $dirty.
$invalid и все остальное (частные валидаторы) срабатывают сразу, без потребности в $touch().

Поэтому $invalid будет давать false даже тогда, когда мы <input> еще и не посещали.


## Селективность запуска $touch().
this.$v.$touch()          //для ВСЕХ переменных.
this.$v.forms.$touch()      //только для forms-переменной.
this.$v.forms.age.$touch()     //только для конкретного age-поля (по данному <input>) у forms-переменной.
this.$v.form.age.required        //по данному валидатору у конкретного поля (по данному <input>).


## = Запуск $touch() в html напрямую.
<input @blur="$v.age.$touch()" v-modal="age">


## Запуск $touch() в html косвенно.
<input v-modal="$v.age.$modal">

Здесь значение v-modal (значение из <input>) НЕ связано с data().
Значение <input> поступает via v-modal сначала в валидатор, и лиш затем, из валидатора, - в data().

Одновременно имитируется запуск $touch(), 
т.е. запускать отдельно $touch() уже нужды нет.


## Запуск $touch() в JS.
methods: {
  submit() {
    this.$v.$touch()
    if(this.$v.forms.age.$dirty) {
      //do anything
    }
  }
}




# Валидация отдельнойё ГРУППЫ полей скопом
  Часть полей можно объединить, приписав им групповой ответ по влидации,
- валидны ли все поля, собранные в данную группу?
  
  validations: {
  flatA: { required },
  flatB: { required },
  forGroup: {
    nested: { required }
  },
  validationGroup: ['flatA', 'flatB', 'forGroup.nested']
}

Результат валидации будет отображаться так
$v.validationGroup = {
  "$model": null,
  "$invalid": false,
  "$dirty": true,
  "$anyDirty": true,
  "$error": false,
  "$anyError": false,
  "$pending": false
}




  
  
# Методы у this.$v.
## $v.touch()
- присуждает true у $dirty
Он должен сопутствовать только $dirty и $error.
Без $dirty - $invalid будет продолжать работать.


## $v.$reset
- присуждает false у $dirty


## $v.$flattenParams
- выдает массив параметров.
Нр:
[{ path: [], name: 'between', params: { type: 'between', min: 5, max: 10 } }, ]
  

## $v.name.$params.minLenght.min
- аргумент в валидаторе minLenght




# Способы использования результата валидации.
## Использование в CSS-стилях.
<div :class="{error: $v.name.$error,
              valid: !$v.name.$invalid && name
     }"
> 
</div>

Если name=null, то $v.name.$invalid даст true(!).
Поэтому при использовании $invalid,
что бы при пустом поле <input> не было валидного CSS-класса,
сочетаем $invalid со значением проверяемой переменной, взятой тупо из data().




## Использование в html.
<div v-if="!$v.age.mustBeCool">Really!</div>




## Использование в JS => позволение SUBMIT'a.
Ключ - this.$v.$invalid.

methods: {
  submit() {
    this.$v.$touch()    //активация $dirty

    if(!this.$v.$invalid) {        // но ведь для $invalid не требуется запускать $touch(), типо. ???.
    //или
    if(this.$v.forms.$dirty && !this.$v.forms.$anyError) {
      this.submitStatus = 'PENDING'
      //submit logic
      setTimeout(() => {
        this.submitStatus = 'OK'
      }, 500)
    } else {
      this.submitStatus = 'ERROR'
    }
  }
}
<p v-if="submitStatus === 'OK'">Thanks for your submission!</p>
<p v-if="submitStatus === 'ERROR'">Please fill the form correctly.</p>
<p v-if="submitStatus === 'PENDING'">Sending...</p>



## Второй вариант контроля SUBMIT'a (хуже).
<button :disabled="$v.$invalid">SUBMIT</button> 

