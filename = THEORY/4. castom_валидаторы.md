# Общее
## Имя валидатора
- произвольное.
Оно значимо только для снятия результата валидности:

<div v-if="!$v.myField.mustBeCool">Really!</div>

## Return валидатора
- true/false 
- ПРОМИС(!), содержащий тоже true/false.
- null расценивается как true(!)

В аргумент функции АВТОМАТИЧЕСКИ подается валидируемое значение.




## Учитываем внешний ПАРАМЕТР и избегаем валидацию при noDirty-состоянии.
import { helpers } from 'vuelidate/lib/validators'

let cool = 'Привет!'
const contains = cool => async (value) => !helpers.req(value) || value.indexOf(param) >= 0
//Если прописываем async для ПЕРВОЙ функции, то НЕ работает(!).

validations: {
  myField: {
    mustBeCool: contains(cool)    //cool - это переменная, внешний параметр
  }
}




# Кастомный валидатор просто.
const isPhone = (v: string): boolean => {
  let re = /[(][0-9]{3}[)]\s[0-9]{3}[-][0-9]{2}[-][0-9]{2}/       //(999) 999-99-99
  re.lastIndex = 0
  return !helpers.req(v) || re.test(v)
}

validations: {
  forms: {
    login: {
      value: {
        isPhone
        isPhone: isPhone
        isPhone: isPhone()    // так писать нельзя(!). Если ставим скобки, то это подразумевает, что мы загоняем ВТОРОЙ аргумент
        isPhone: isPhone(this.agr_2)    //так писать можно, но для функции (arg_2) => (value) => return true;
      }
    }
  }
},



# Хелперы.
import { helpers } from "vuelidate/lib/validators"

## !helpers.req(value)
- имитирует проверку поля по принципу, если бы было выставлено условие required.
Причем null приравнивается к присутствию значения.
  
Применяется только в кастомных валидаторах,
в частности - для исключения срабатывания валидации, если <input> еще не заполнялся, (ставим в отрицании - !).
Если value - пустой, то helpers.req(value) возвращает false.

const mustBeCool = value => !helpers.req(value) || value.includes("cool")

## helpers.







# Асинхронные промисные валидаторы.
//https://vuelidate.js.org/#sub-asynchronous-validation

Функция валидатора может возвращать промис, а не только чистый boolean.
Пропускать результат сквозь .then() не требуется.
Если в resolve возвратится true - валидация будет положительной, false - отрицательной,
если reject - валидация будет отрицательной.

AXIOS - возвращает Promise.resolve({data: responseBody}),
поэтому сходу его ретернить не получиться.

<input @blur="$v.username.$touch()" v-modal.lezy="age">    //.lezy- важно(!).
<div v-show="$v.username.$pending">louding...</div>
<div v-show="!$v.username.isUnique">не нашли</div>
  
validations: {
  username: {
    required,
    isUnique: async isUnique,
    async isUnique(value) {
      if (value === '') return true    //если поле пустое, то проверку на сервере не запускаем. Проверять нечего.
      //или
      if(!helpers.req(value)) return true

      return Boolean(await fetch(`/api/unique/${value}`)        //<=
      //или
      return new Promise((resolve, reject) => {            //right
        aweit axios.get(`api/checkUser/${username}`)
          .then(response => resolve(response.ok))
          .catch(() => resolve(false))
      })
      //или
      return axios.get(`api/checkUser/${username}`)        //wrong

      //или
      return new Promise((resolve, reject) => {       //<=
        setTimeout(() => {
          resolve(value.length % 2 !== 0)      // или можно написать reject(any) ==> false.
        }, 3000)
      })
    }
  }
}


export const isUnique = async (isRegistrationInterface: boolean) => async (value: string): Promise<AuthResponse | boolean> => {
  //дополнительно лучше у v-modal добавить директиву .lezy, ее роль маска не играет.
  if (value === '' && !isRegistrationInterface)
    return Promise.resolve(true) 
  return await axios.get(`api/checkOutAuthData/${value}`)
}


validations: {
  async isUnique (value) {     //валидатор применяется ко всем полям подряд??
    if (value === '') 
      return true

    const response = await fetch(`/api/unique/${value}`)
    return Boolean(await response.json())
  }
}

<div v-if="!$v.username.isUnique">Предлагаемый Вами логин уже существует</div>

## Промисный валидатор с ВНЕШНИМ аргументом
async надо указывать ТОЛЬКО у второй функции(!).

export const isUnique = (isRegistration: boolean) => async (login: Identification): Promise<boolean> => {  
  let isLogin: boolean = false

  if(isRegistration) {
    await axios.get(`api/identification/${login}`)
      .then(({data}) => isLogin = data.isLogin)
      .catch(console.log)
  }
  return Promise.resolve(isLogin)
}




